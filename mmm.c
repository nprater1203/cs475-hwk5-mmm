/*
	Name: Nicholas Prater
	Course: CS 481 OS
	Professor: Dr. Chiu
	Date: 3/7/23
*/

#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "rtclock.h"
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */
void mmm_init()
{
	// TODO
	time_t t;
	srand((unsigned) time(&t));

	array1 = (double **)malloc(sizeof(double *) * size);
	array2 = (double **)malloc(sizeof(double *) * size);
	sMatrix = (double **)malloc(sizeof(double *) * size);
	pMatrix = (double **)malloc(sizeof(double *) * size);

	// iterate through each row and malloc a size N array of ints
	for (int i = 0; i < size; i++)
	{
		array1[i] = (double *)malloc(sizeof(double) * size);
		array2[i] = (double *)malloc(sizeof(double) * size);
		sMatrix[i] = (double *)malloc(sizeof(double) * size);
		pMatrix[i] = (double *)malloc(sizeof(double) * size);
	}

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			double checkNum = rand() % 100;
			if(checkNum == 0)
			{
				array1[i][j] = checkNum + 1;
			}
			else
			{
				array1[i][j] = checkNum;
			}

			checkNum = rand() % 100;
			if(checkNum == 0)
			{
				array2[i][j] = checkNum + 1;
			}
			else
			{
				array2[i][j] = checkNum;
			}

			sMatrix[i][j] = 0;
			pMatrix[i][j] = 0;
		}
	}
}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix)
{
	// TODO
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			matrix[i][j] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	// TODO
	// free each row
	for (int i = 0; i < size; i++)
	{
		free(array1[i]);
		array1[i] = NULL; // remove dangling pointer
		free(array2[i]);
		array2[i] = NULL; // remove dangling pointer
		free(sMatrix[i]);
		sMatrix[i] = NULL; // remove dangling pointer
		free(pMatrix[i]);
		pMatrix[i] = NULL; // remove dangling pointer
	}

	// free original array
	free(array1);
	array1 = NULL; // remove dangling pointer
	free(array2);
	array2 = NULL; // remove dangling pointer
	free(sMatrix);
	sMatrix = NULL; // remove dangling pointer
	free(pMatrix);
	pMatrix = NULL; // remove dangling pointer
}

/**
 * Sequential MMM
 */
void mmm_seq()
{
	// TODO - code to perform sequential MMM
	int b = 0;
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			sMatrix[i][b] += array1[i][j] * array2[j][i];
			b++;
		}
		b = 0;
	}

}

/**
 * Parallel MMM
 */
void *mmm_par(void *args)
{
	// TODO - code to perform parallel MMM
	thread_args *params = (thread_args *)args;
	int b = 0;
	for (int i = params->begin; i < params->end; i++)
	{
		for (int j = params->begin; j < params->end; j++)
		{
			pMatrix[i][b] += array1[i][j] * array2[j][i];
			b++;
		}
		b = 0;
	}
	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify()
{
	// TODO
	double largestDif = 0;

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			if (sMatrix[i][j] != pMatrix[i][j])
			{
				if (largestDif > abs(sMatrix[i][j] - pMatrix[i][j]))
				{
					largestDif = abs(sMatrix[i][j] - pMatrix[i][j]);
				}
			}
		}
	}
	return largestDif;
}

