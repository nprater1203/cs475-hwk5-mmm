/*
	Name: Nicholas Prater
	Course: CS 481 OS
	Professor: Dr. Chiu
	Date: 3/7/23
*/

#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "rtclock.h"
#include "mmm.h"

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */
void mmm_init()
{
	// TODO
	// malloc a size N array of pointers to ints
	time_t t;
	srand((unsigned) time(&t));

	array1 = (double **)malloc(sizeof(double *) * size);
	array2 = (double **)malloc(sizeof(double *) * size);
	sMatrix = (double **)malloc(sizeof(double *) * size);
	pMatrix = (double **)malloc(sizeof(double *) * size);

	// iterate through each row and malloc a size N array of ints
	for (int i = 0; i < size; i++)
	{
		array1[i] = (double *)malloc(sizeof(double) * size);
		array2[i] = (double *)malloc(sizeof(double) * size);
		sMatrix[i] = (double *)malloc(sizeof(double) * size);
		pMatrix[i] = (double *)malloc(sizeof(double) * size);
	}

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			array1[i][j] = rand() % 100;
			array2[i][j] = rand() % 100;
		}
	}
	// printf("ARRAY 1\n");

	// for (int i = 0; i < size; i++)
	// {
	// 	for (int j = 0; j < size; j++)
	// 	{
	// 		printf("%f ", array1[i][j]);
	// 	}
	// 	printf("\n");
	// }
	// printf("ARRAY 2\n");
	// for (int i = 0; i < size; i++)
	// {
	// 	for (int j = 0; j < size; j++)
	// 	{
	// 		printf("%f ", array2[i][j]);
	// 	}
	// 	printf("\n");
	// }
}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix)
{
	// TODO
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			sMatrix[i][j] = 0;
			pMatrix[i][j] = 0;
		}
	}
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	// TODO
	// free each row
	for (int i = 0; i < size; i++)
	{
		free(array1[i]);
		array1[i] = NULL; // remove dangling pointer
		free(array2[i]);
		sMatrix[i] = NULL; // remove dangling pointer
		free(sMatrix[i]);
		pMatrix[i] = NULL; // remove dangling pointer
		free(pMatrix[i]);
	}

	// free original array
	free(array1);
	array1 = NULL; // remove dangling pointer
	free(array2);
	array2 = NULL; // remove dangling pointer
	free(sMatrix);
	sMatrix = NULL; // remove dangling pointer
	free(pMatrix);
	pMatrix = NULL; // remove dangling pointer
}

/**
 * Sequential MMM
 */
void mmm_seq()
{
	// TODO - code to perform sequential MMM
	int b = 0;
	// double temp = 0;
	//printf("SEQ MATRIX\n");

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			//printf("Mutiply: %f\n",  array1[i][j] * array2[j][i]);
			sMatrix[i][b] += array1[i][j] * array2[j][i];
			b++;
		}
		// printf("matrix = %f", sMatrix[i][b]);
		// temp = 0;
		b = 0;
	}
	// printf("S Matrix\n");

	// for (int i = 0; i < size; i++)
	// {
	// 	for (int j = 0; j < size; j++)
	// 	{
	// 		printf("%f ", sMatrix[i][j]);
	// 	}
	// 	printf("\n");
	// }
}

/**
 * Parallel MMM
 */
void *mmm_par(void *args)
{
	// TODO - code to perform parallel MMM
	thread_args *params = (thread_args *)args;
	// printf("Begin: %ld\nEnd: %ld\n", params->begin,params->end);
	int b = 0;
	// double temp = 0;
	//printf("PAR MATRIX\n");
	for (int i = params->begin; i < params->end; i++)
	{
		for (int j = params->begin; j < params->end; j++)
		{
			// printf("Mutiply: %f\n",  array1[i][j] * array2[j][i]);
			pMatrix[i][b] += array1[i][j] * array2[j][i];
			b++;
		}
		// printf("matrix = %f\n", sMatrix[i][b]);
		// temp = 0;
		b = 0;
	}
	// printf("P Matrix\n");

	// 	for (int i = 0; i < size; i++)
	// {
	// 	for (int j = 0; j < size; j++)
	// 	{
	// 		printf("%f ", pMatrix[i][j]);
	// 	}
	// 	printf("\n");
	// }
	return NULL;
}

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify()
{
	// TODO
	double largestDif = 0;

	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			//printf("Check: seq %f and par %f\n", sMatrix[i][j], pMatrix[i][j]);
			if (sMatrix[i][j] != pMatrix[i][j])
			{
				if (largestDif < abs(sMatrix[i][j] - (pMatrix[i][j]/numThreads)))
				{
					largestDif = abs(sMatrix[i][j] - pMatrix[i][j]);
				}
			}
		}
	}

	return largestDif;
}

